<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>迷路TD - エンハンストエディション</title>
  <meta name="description" content="拡張版迷路型タワーディフェンス：タワーアップグレード、特殊能力、多様な敵と戦略的な防衛を楽しめます" />
  <style>
    :root{
      --bg: #0a0e14; 
      --panel: #0f1520; 
      --ink: #e6edf3; 
      --muted: #93a0ad; 
      --ok: #10b981; 
      --warn: #f59e0b; 
      --bad: #ef4444;
      --accent1: #60a5fa;
      --accent2: #a78bfa;
      --accent3: #34d399;
      
      --bar: 104px;
      --tile: 44px;
      --grid-w: 12;
      --grid-h: 16;
    }
    *{box-sizing:border-box;touch-action:manipulation}
    html,body{
      height:100dvh;margin:0;background:var(--bg);color:var(--ink);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans JP","Hiragino Kaku Gothic ProN","Yu Gothic",Meiryo,sans-serif;
      overflow:hidden;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;
    }
    #wrap{min-height:100%;display:grid;grid-template-rows:1fr auto;}
    #fieldWrap{
      position:relative;overflow:hidden;border-bottom:1px solid #1f2937;
      touch-action:none;background-image:radial-gradient(circle at 50% 50%, #131a25 0%, #0a0e14 100%);
    }
    #grid{
      position:relative;display:grid;
      grid-template-columns:repeat(var(--grid-w), var(--tile));
      grid-template-rows:repeat(var(--grid-h), var(--tile));
      width:calc(var(--grid-w) * var(--tile));
      height:calc(var(--grid-h) * var(--tile));
      margin:0 auto;touch-action:none;
      background-image:linear-gradient(rgba(18,27,39,0.3) 1px, transparent 1px),
        linear-gradient(90deg, rgba(18,27,39,0.3) 1px, transparent 1px);
      background-size:var(--tile) var(--tile);
    }
    .cell{width:var(--tile);height:var(--tile);border:1px solid rgba(15,23,42,0.5);background:rgba(11,18,32,0.5)}
    .cell.path{background:rgba(12,37,60,0.6);box-shadow:inset 0 0 10px rgba(32,120,220,0.3)}
    .cell.start{background:radial-gradient(circle, rgba(19,78,74,0.8) 0%, rgba(19,78,74,0.4) 70%);box-shadow:inset 0 0 15px rgba(72,187,120,0.5)}
    .cell.goal{background:radial-gradient(circle, rgba(74,19,19,0.8) 0%, rgba(74,19,19,0.4) 70%);box-shadow:inset 0 0 15px rgba(239,68,68,0.5)}
    .entity{position:absolute;pointer-events:none;translate:-50% -50%;transition:transform 0.1s ease-out;}
    .enemy{width:28px;height:28px;border-radius:6px;background:#ef4444;box-shadow:0 0 0 2px rgba(0,0,0,.25);animation:pulse 1.5s infinite alternate;}
    .enemy.tank{width:34px;height:34px;background:linear-gradient(145deg, #b91c1c, #991b1b);animation:tankMove 2s infinite alternate;}
    .enemy.bike{width:24px;height:24px;background:linear-gradient(145deg, #f97316, #ea580c);animation:bikeMove 0.8s infinite alternate;}
    .enemy.boss{width:46px;height:46px;background:radial-gradient(circle, #7f1d1d, #450a0a);outline:3px solid #fecaca;animation:bossPulse 1s infinite alternate;}
    .enemy.elite{width:32px;height:32px;background:linear-gradient(145deg, #c026d3, #86198f);box-shadow:0 0 10px rgba(192,38,211,0.7);animation:elitePulse 1.2s infinite alternate;}
    .tower,.unit{width:30px;height:30px;border-radius:4px;background:#60a5fa;border:2px solid #1d4ed8;box-shadow:0 0 8px rgba(96,165,250,0.6);}
    .tower.sniper{background:linear-gradient(145deg, #a78bfa, #7c3aed);border-color:#6d28d9;box-shadow:0 0 8px rgba(167,139,250,0.6);}
    .tower.mg{background:linear-gradient(145deg, #34d399, #059669);border-color:#059669;box-shadow:0 0 8px rgba(52,211,153,0.6);}
    .tower.rocket{background:linear-gradient(145deg, #f97316, #ea580c);border-color:#c2410c;box-shadow:0 0 8px rgba(249,115,22,0.6);}
    .unit.infantry{background:linear-gradient(145deg, #f59e0b, #d97706);border-color:#b45309;box-shadow:0 0 8px rgba(245,158,11,0.6);}
    .unit.vehicle{background:linear-gradient(145deg, #cbd5e1, #94a3b8);border-color:#475569;box-shadow:0 0 8px rgba(203,213,225,0.6);}
    .trap.mine{width:22px;height:22px;border-radius:50%;background:#f43f5e;border:2px dashed #7f1d1d;animation:pulse 1.2s infinite alternate;}
    .trap.slow{width:34px;height:34px;border-radius:6px;background:rgba(30,41,59,0.8);border:2px solid #334155;animation:slowPulse 2s infinite alternate;}
    .bullet{width:6px;height:6px;border-radius:50%;background:#eab308;box-shadow:0 0 4px rgba(234,179,8,0.8);}
    .rocket{width:12px;height:6px;background:linear-gradient(90deg, #f97316, #f59e0b);border-radius:3px;box-shadow:0 0 8px rgba(249,115,22,0.8);}
    .laser{height:2px;background:linear-gradient(90deg, rgba(167,139,250,0.8), transparent);transform-origin:0 50%;}
    .ghost{position:absolute;pointer-events:none;border:2px dashed rgba(147,197,253,0.5);border-radius:10px;background:rgba(96,165,250,0.1);translate:-50% -50%;}
    .range-circle{position:absolute;border-radius:50%;border:1px solid rgba(96,165,250,0.5);background:rgba(96,165,250,0.1);translate:-50% -50%;pointer-events:none;}
    .upgrade-indicator{position:absolute;width:10px;height:10px;background:var(--warn);border-radius:50%;bottom:2px;right:2px;border:1px solid rgba(0,0,0,0.3);}
    .health-bar{position:absolute;width:80%;height:3px;background:#1f2937;bottom:-6px;left:10%;border-radius:2px;overflow:hidden;}
    .health-fill{height:100%;background:var(--ok);width:100%;transition:width 0.2s ease;}
    
    /* パーティクル効果 */
    .particle{position:absolute;pointer-events:none;border-radius:50%;}
    .explosion{position:absolute;width:60px;height:60px;border-radius:50%;background:radial-gradient(circle, rgba(249,115,22,0.8) 0%, transparent 70%);pointer-events:none;animation:explode 0.5s forwards;}
    
    /* アニメーション */
    @keyframes pulse{from{transform:scale(1);} to{transform:scale(1.05);}}
    @keyframes tankMove{0%{transform:translateY(0);} 100%{transform:translateY(2px);}}
    @keyframes bikeMove{0%{transform:rotate(-3deg);} 100%{transform:rotate(3deg);}}
    @keyframes bossPulse{0%{box-shadow:0 0 0 3px rgba(254,202,202,0.5);} 100%{box-shadow:0 0 0 6px rgba(254,202,202,0.8);}}
    @keyframes elitePulse{0%{box-shadow:0 0 5px rgba(192,38,211,0.5);} 100%{box-shadow:0 0 15px rgba(192,38,211,0.9);}}
    @keyframes slowPulse{0%{opacity:0.6;} 100%{opacity:1;}}
    @keyframes explode{0%{transform:scale(0); opacity:1;} 100%{transform:scale(1.5); opacity:0;}}
    @keyframes float{0%{transform:translateY(0);} 100%{transform:translateY(-4px);}}
    @keyframes glow{0%{box-shadow:0 0 5px rgba(96,165,250,0.6);} 100%{box-shadow:0 0 15px rgba(96,165,250,0.9);}}
    
    #bar{position:relative;background:var(--panel);padding:8px 10px calc(8px + env(safe-area-inset-bottom));display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center;min-height:var(--bar);}
    #stats{display:flex;gap:12px;align-items:center;font-size:14px;color:var(--muted)}
    #stats b{color:var(--ink)}
    #palette{display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end}
    .item{display:flex;flex-direction:column;align-items:center;gap:4px;background:#111827;border:1px solid #1f2937;padding:6px 8px;border-radius:10px;min-width:62px;transition:all 0.2s ease;}
    .item:hover{transform:translateY(-2px);box-shadow:0 4px 8px rgba(0,0,0,0.2);}
    .item.sel{outline:2px solid var(--accent1);background:#1a2537;}
    .item .ico{width:28px;height:28px;border-radius:6px}
    .item .name{font-size:12px;color:#cbd5e1}
    .item .cost{font-size:11px;color:#9aa4b2}
    #skills{display:flex;gap:6px;margin-top:4px;}
    .skill-btn{background:#1f2937;border:1px solid #374151;border-radius:6px;padding:4px 8px;font-size:11px;color:#cbd5e1;cursor:pointer;transition:all 0.2s ease;}
    .skill-btn:disabled{opacity:0.5;cursor:not-allowed;}
    .skill-btn:not(:disabled):active{transform:translateY(1px)}
    
    #ctrls{position:absolute;left:10px;top:10px;display:flex;gap:8px;z-index:3}
    .btn{appearance:none;border:none;border-radius:999px;background:#1f2937;color:#e5e7eb;padding:8px 12px;font-size:12px;transition:all 0.2s ease;}
    .btn:hover{background:#2a374b;}
    .btn:active{transform:translateY(1px)}
    .btn.primary{background:var(--accent1);color:white;}
    .btn.warning{background:var(--warn);color:white;}
    .btn.danger{background:var(--bad);color:white;}
    
    .overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.75);z-index:10;backdrop-filter:blur(4px);}
    .overlay.show{display:flex;animation:fadeIn 0.3s ease;}
    .panel{background:#0f1520;border:1px solid #1f2937;border-radius:16px;max-width:520px;width:92%;padding:20px;box-shadow:0 10px 25px rgba(0,0,0,0.5);}
    .panel h1{font-size:22px;margin:0 0 8px;color:var(--accent1);text-align:center;}
    .panel h2{font-size:16px;margin:10px 0 6px;color:#cbd5e1}
    .panel p{margin:4px 0;color:#9aa4b2;line-height:1.5;}
    .row{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    .chip{border:1px solid #374151;background:#111827;color:#e5e7eb;padding:8px 16px;border-radius:999px;font-size:14px;transition:all 0.2s ease;cursor:pointer;}
    .chip:hover{background:#1a2537;}
    .chip.sel{outline:2px solid var(--accent1);background:#1a2537;}
    #toast{position:absolute;left:50%;top:14px;transform:translateX(-50%);background:#111827;border:1px solid #1f2937;color:#e5e7eb;border-radius:999px;padding:8px 16px;font-size:13px;opacity:0;transition:opacity .2s;z-index:6;box-shadow:0 4px 12px rgba(0,0,0,0.3);}
    #toast.show{opacity:1;}
    
    /* アップグレードUI */
    .upgrade-ui{position:absolute;background:#0f1520;border:1px solid #1f2937;border-radius:12px;padding:12px;z-index:4;box-shadow:0 5px 15px rgba(0,0,0,0.3);display:none;}
    .upgrade-ui h3{margin:0 0 8px;font-size:14px;color:var(--accent1);}
    .upgrade-option{display:flex;justify-content:space-between;align-items:center;padding:6px 0;border-bottom:1px solid #1f2937;}
    .upgrade-option:last-child{border-bottom:none;}
    .upgrade-btn{background:var(--accent1);color:white;border:none;border-radius:6px;padding:4px 8px;font-size:12px;cursor:pointer;}
    .upgrade-btn:disabled{opacity:0.5;cursor:not-allowed;}
    
    /* ヒント表示 */
    .hint{position:absolute;background:rgba(17,24,39,0.9);border:1px solid #374151;border-radius:8px;padding:8px 12px;font-size:12px;color:#cbd5e1;z-index:4;max-width:200px;display:none;}
    
    @keyframes fadeIn{from{opacity:0;} to{opacity:1;}}
  </style>
</head>
<body>
  <div id="wrap">
    <div id="fieldWrap">
      <div id="ctrls">
        <button class="btn primary" id="btnStartWave">Wave開始</button>
        <button class="btn warning" id="btnPause">一時停止</button>
        <button class="btn" id="btnSpeed">速度×1</button>
        <button class="btn" id="btnSkill1" data-skill="airStrike">空爆支援</button>
        <button class="btn" id="btnSkill2" data-skill="freeze">時間停止</button>
      </div>
      <div id="grid" aria-label="戦場"></div>
      <div id="toast"></div>
      <div id="upgradeUI" class="upgrade-ui"></div>
      <div id="hint" class="hint"></div>
      
      <div id="overlay" class="overlay show" role="dialog" aria-modal="true">
        <div class="panel">
          <h1>迷路TD - エンハンストエディション</h1>
          <p>拡張版迷路型タワーディフェンス！タワーを戦略的に配置し、多様な敵の波を防衛せよ。</p>
          <p>新機能: タワーアップグレード、特殊能力、多様な敵タイプ、ビジュアルエフェクト</p>
          
          <h2>難易度を選択</h2>
          <div class="row" id="difficulty">
            <button class="chip" data-diff="easy">Easy</button>
            <button class="chip sel" data-diff="normal">Normal</button>
            <button class="chip" data-diff="hard">Hard</button>
            <button class="chip" data-diff="extreme">Extreme</button>
          </div>
          
          <h2>ゲームモード</h2>
          <div class="row" id="gameMode">
            <button class="chip sel" data-mode="standard">標準</button>
            <button class="chip" data-mode="endless">エンドレス</button>
            <button class="chip" data-mode="speed">スピードラン</button>
          </div>
          
          <div class="row" style="justify-content:flex-end;margin-top:16px">
            <button class="btn primary" id="btnStartGame">ゲーム開始</button>
          </div>
        </div>
      </div>
      
      <div id="result" class="overlay" role="dialog" aria-modal="true">
        <div class="panel">
          <h1 id="resultTitle">結果</h1>
          <p id="resultStats"></p>
          <div id="highScore" style="margin:12px 0;padding:8px;background:#111827;border-radius:8px;"></div>
          <div class="row" style="justify-content:flex-end;margin-top:12px">
            <button class="btn" id="btnRestart">再プレイ</button>
            <button class="btn primary" id="btnBackTitle">タイトルへ</button>
          </div>
        </div>
      </div>
    </div>
    
    <div id="bar">
      <div id="stats">
        <div>💰 <b id="money">0</b></div>
        <div>❤️ <b id="life">0</b></div>
        <div>📶 Wave <b id="wave">0</b>/10</div>
        <div>⭐ <b id="score">0</b></div>
        <div>⚡ <b id="skill1CD">0</b>s</div>
        <div>❄️ <b id="skill2CD">0</b>s</div>
      </div>
      <div id="palette" aria-label="配置パレット"></div>
    </div>
  </div>

<script>
(()=>{
  "use strict";
  /* ===== ユーティリティ ===== */
  const $ = (sel, el=document)=>el.querySelector(sel);
  const $$ = (sel, el=document)=>Array.from(el.querySelectorAll(sel));
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
  const rand = (a,b)=>a+Math.random()*(b-a);
  const toastEl = $('#toast'); 
  let toastTimer=null; 
  function toast(msg, duration=1200){ 
    toastEl.textContent = msg; 
    toastEl.classList.add('show'); 
    clearTimeout(toastTimer); 
    toastTimer = setTimeout(()=>toastEl.classList.remove('show'), duration); 
  }
  
  // ヒント表示機能
  const hintEl = $('#hint');
  let hintTimer = null;
  function showHint(msg, x, y, duration=2000) {
    hintEl.textContent = msg;
    hintEl.style.left = x + 'px';
    hintEl.style.top = y + 'px';
    hintEl.style.display = 'block';
    clearTimeout(hintTimer);
    hintTimer = setTimeout(() => hintEl.style.display = 'none', duration);
  }

/* ===== 定数・ゲーム設定 ===== */ 
const GRID_W = 12; 
const GRID_H = 16; 
const TILE = ()=>parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile'));

const START = {x:0, y:Math.floor(GRID_H/2)};
const GOAL  = {x:GRID_W-1, y:Math.floor(GRID_H/2)};

const DIFFS = { 
  easy:   { enemyHP:0.8, enemyNum:0.8, reward:1.2, startMoney: 250, life:25, enemySpd:0.9 },
  normal: { enemyHP:1.0, enemyNum:1.0, reward:1.0, startMoney: 200, life:20, enemySpd:1.0 },
  hard:   { enemyHP:1.3, enemyNum:1.2, reward:0.9, startMoney: 160, life:16, enemySpd:1.1 },
  extreme:{ enemyHP:1.6, enemyNum:1.4, reward:0.8, startMoney: 120, life:12, enemySpd:1.2 },
};

// ゲームモード
const MODES = {
  standard: { waves: 10, endless: false },
  endless: { waves: Infinity, endless: true },
  speed: { waves: 10, endless: false, speedMultiplier: 1.3 }
};

// パレット定義（タワー/罠/ユニット）
const ITEMS = [
  { key:'tower_basic',  kind:'tower', name:'基本',   cost:60,  range:2.5, dmg:10,  rof:1.0, iconClass:'tower', upgrades: 3 },
  { key:'tower_sniper', kind:'tower', name:'狙撃',   cost:110, range:5.0, dmg:30,  rof:0.4, iconClass:'tower sniper', upgrades: 2 },
  { key:'tower_mg',     kind:'tower', name:'連射',   cost:85,  range:2.2, dmg:6,   rof:3.0, iconClass:'tower mg', upgrades: 3 },
  { key:'tower_rocket', kind:'tower', name:'ロケット',cost:140, range:3.5, dmg:45,  rof:0.8, iconClass:'tower rocket', upgrades: 2, splash: 1.2 },

  { key:'trap_mine',    kind:'trap',  name:'地雷',   cost:35,  iconClass:'trap mine' },
  { key:'trap_slow',    kind:'trap',  name:'減速',   cost:55,  slow:0.55, iconClass:'trap slow', duration: 8 },

  { key:'unit_inf',     kind:'unit',  name:'歩兵',   cost:50,  range:1.8, dmg:8,   rof:1.2, iconClass:'unit infantry', hp: 40 },
  { key:'unit_vehicle', kind:'unit',  name:'車両',   cost:120, range:2.4, dmg:14,  rof:1.0, iconClass:'unit vehicle', hp: 80 },
];

// ウェーブ構成（敵スポーンテーブル）
const WAVES = [
  { list:[ {type:'inf', n:10, gap:0.8} ] },
  { list:[ {type:'inf', n:14, gap:0.7} ] },
  { list:[ {type:'inf', n:16, gap:0.6}, {type:'bike', n:3, gap:1.0} ] },
  { list:[ {type:'bike', n:8, gap:0.8}, {type:'inf', n:10, gap:0.6} ] },
  { list:[ {type:'bike', n:12, gap:0.7}, {type:'elite', n:2, gap:2.0} ] },
  { list:[ {type:'tank', n:4, gap:1.5}, {type:'bike', n:8, gap:0.7} ] },
  { list:[ {type:'tank', n:6, gap:1.2}, {type:'inf', n:12, gap:0.5} ] },
  { list:[ {type:'tank', n:8, gap:1.0}, {type:'elite', n:4, gap:1.5} ] },
  { list:[ {type:'elite', n:8, gap:1.0}, {type:'bike', n:10, gap:0.6} ] },
  { list:[ {type:'boss', n:1, gap:0.0}, {type:'elite', n:4, gap:1.0} ] },
  // エンドレスモード用の追加ウェーブ
  { list:[ {type:'inf', n:20, gap:0.5}, {type:'bike', n:10, gap:0.7} ] },
  { list:[ {type:'tank', n:10, gap:1.0}, {type:'elite', n:6, gap:1.2} ] },
  { list:[ {type:'boss', n:2, gap:2.0}, {type:'elite', n:8, gap:0.8} ] },
  { list:[ {type:'inf', n:30, gap:0.4}, {type:'bike', n:15, gap:0.6}, {type:'elite', n:5, gap:1.0} ] },
];

const ENEMY_BASE = { 
  inf:  { hp: 30,  spd: 1.0, reward: 6,  dmg:1, class:'enemy' }, 
  bike: { hp: 26,  spd: 1.8, reward: 8,  dmg:1, class:'enemy bike' }, 
  tank: { hp: 180, spd: 0.6, reward: 20, dmg:2, class:'enemy tank' }, 
  boss: { hp: 1200,spd: 0.5, reward: 120,dmg:5, class:'enemy boss' },
  elite:{ hp: 80,  spd: 1.2, reward: 15, dmg:2, class:'enemy elite' },
};

// 特殊能力
const SKILLS = {
  airStrike: { name: "空爆支援", desc: "指定地点に爆撃を行い範囲ダメージ", cost: 100, cooldown: 20, active: false },
  freeze: { name: "時間停止", desc: "すべての敵を5秒間凍結させる", cost: 150, cooldown: 30, active: false }
};

/* ===== グリッド生成 ===== */ 
const gridEl = $('#grid'); 
const fieldWrap = $('#fieldWrap');

function resizeField(){ 
  const vh = window.innerHeight;
  const bar = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--bar')); 
  const usableH = Math.max(200, vh - bar - 8); 
  const usableW = window.innerWidth - 8; 
  const tileH = Math.floor(usableH / GRID_H); 
  const tileW = Math.floor(usableW / GRID_W); 
  const tile = Math.max(28, Math.min(56, Math.min(tileH, tileW)));
  document.documentElement.style.setProperty('--tile', tile+'px'); 
  fieldWrap.style.minHeight = `calc(100dvh - ${bar}px)`;
} 
window.addEventListener('resize', resizeField);
resizeField();

// ランダムなマップ生成
function generateMap() {
  const arr = Array.from({length:GRID_H},()=>Array(GRID_W).fill(0));
  
  // スタートとゴールは必ず空き
  arr[START.y][START.x] = 0;
  arr[GOAL.y][GOAL.x] = 0;
  
  // 迷路生成アルゴリズム (簡易版)
  for(let y = 1; y < GRID_H-1; y++) {
    for(let x = 1; x < GRID_W-1; x++) {
      // スタートとゴール周辺は空ける
      if ((x >= START.x-1 && x <= START.x+1 && y >= START.y-1 && y <= START.y+1) ||
          (x >= GOAL.x-1 && x <= GOAL.x+1 && y >= GOAL.y-1 && y <= GOAL.y+1)) {
        continue;
      }
      
      // ランダムに壁を配置
      if (Math.random() < 0.3) {
        arr[y][x] = 1;
      }
    }
  }
  
  return arr;
}

const map = generateMap();

function renderGrid(){ 
  gridEl.innerHTML = ''; 
  for(let y=0;y<GRID_H;y++){ 
    for(let x=0;x<GRID_W;x++){ 
      const d = document.createElement('div'); 
      d.className = 'cell'; 
      d.dataset.x = x; 
      d.dataset.y = y; 
      if((x===START.x && y===START.y)) d.classList.add('start'); 
      if((x===GOAL.x && y===GOAL.y)) d.classList.add('goal'); 
      gridEl.appendChild(d); 
    } 
  } 
}

/* ===== 経路探索（A*） ===== */ 
function astar(start, goal, mapOverride){ 
  const grid = mapOverride || map; 
  const key=(x,y)=>`${x},${y}`; 
  const open=[{x:start.x,y:start.y,g:0,f:0}]; 
  const came=new Map(); 
  const gscore=new Map([[key(start.x,start.y),0]]); 
  const fscore=new Map([[key(start.x,start.y),heur(start,goal)]]);

  function heur(a,b){return Math.abs(a.x-b.x)+Math.abs(a.y-b.y);}
  function neighbors(x,y){
    const arr=[];
    [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
      const nx=x+dx, ny=y+dy;
      if(nx>=0&&nx<GRID_W&&ny>=0&&ny<GRID_H && grid[ny][nx]!==1 && grid[ny][nx]!==4){
        arr.push({x:nx,y:ny});
      }
    });
    return arr;
  }

  while(open.length){
    let best=0; for(let i=1;i<open.length;i++){ if(open[i].f<open[best].f) best=i; }
    const cur=open.splice(best,1)[0];
    if(cur.x===goal.x && cur.y===goal.y){
      const path=[{x:cur.x,y:cur.y}];
      let ck=key(cur.x,cur.y);
      while(came.has(ck)){
        const p=came.get(ck); path.push(p); ck=key(p.x,p.y);
      }
      return path.reverse();
    }
    for(const nb of neighbors(cur.x,cur.y)){
      const tentative = (gscore.get(key(cur.x,cur.y)) ?? Infinity) + 1;
      const nk = key(nb.x,nb.y);
      if(tentative < (gscore.get(nk) ?? Infinity)){
        came.set(nk,{x:cur.x,y:cur.y});
        gscore.set(nk, tentative);
        const f = tentative + heur(nb, goal);
        fscore.set(nk, f);
        if(!open.find(n=>n.x===nb.x&&n.y===nb.y)) open.push({x:nb.x,y:nb.y,g:tentative,f});
      }
    }
  }
  return null;
}

function paintPath(path){ 
  $$('.cell').forEach(c=>c.classList.remove('path')); 
  if(!path) return; 
  for(const p of path){ 
    const cell = $(`.cell[data-x="${p.x}"][data-y="${p.y}"]`); 
    if(cell && !cell.classList.contains('start') && !cell.classList.contains('goal')){ 
      cell.classList.add('path'); 
    } 
  } 
}

/* ===== ゲーム状態 ===== */ 
const state = { 
  running:false, 
  paused:false, 
  speed:1, 
  diff:'normal',
  mode: 'standard',
  money:0, 
  life:20, 
  wave:0,
  score:0,
  enemies:[], 
  towers:[], 
  units:[], 
  traps:[], 
  bullets:[],
  rockets:[],
  skills: {
    airStrike: { ...SKILLS.airStrike, cooldownLeft: 0 },
    freeze: { ...SKILLS.freeze, cooldownLeft: 0, active: false }
  },
  freezeTime: 0,
};

// ハイスコア管理
function getHighScore() {
  return parseInt(localStorage.getItem('mazeTD_highScore') || '0');
}

function setHighScore(score) {
  const current = getHighScore();
  if (score > current) {
    localStorage.setItem('mazeTD_highScore', score);
    return true;
  }
  return false;
}

/* ===== UI ===== */ 
const moneyEl=$('#money'), lifeEl=$('#life'), waveEl=$('#wave'), scoreEl=$('#score');
const skill1CD=$('#skill1CD'), skill2CD=$('#skill2CD');

function refreshStats(){ 
  moneyEl.textContent = state.money|0; 
  lifeEl.textContent = state.life; 
  waveEl.textContent = state.wave; 
  scoreEl.textContent = state.score;
  
  // スキルクールダウン表示
  skill1CD.textContent = state.skills.airStrike.cooldownLeft > 0 ? state.skills.airStrike.cooldownLeft.toFixed(0) : "Ready";
  skill2CD.textContent = state.skills.freeze.cooldownLeft > 0 ? state.skills.freeze.cooldownLeft.toFixed(0) : "Ready";
  
  // スキルボタンの状態更新
  $('#btnSkill1').disabled = state.money < state.skills.airStrike.cost || state.skills.airStrike.cooldownLeft > 0;
  $('#btnSkill2').disabled = state.money < state.skills.freeze.cost || state.skills.freeze.cooldownLeft > 0;
} 

function buildPalette(){ 
  const pal = $('#palette'); 
  pal.innerHTML=''; 
  ITEMS.forEach((it,i)=>{ 
    const d=document.createElement('button'); 
    d.className='item'; 
    d.type='button'; 
    d.dataset.key=it.key; 
    d.dataset.index=i; 
    d.innerHTML = `
      <div class="ico ${it.iconClass}"></div>
      <div class="name">${it.name}</div>
      <div class="cost">${it.cost}</div>
    `; 
    pal.appendChild(d); 
  }); 
}

/* ===== 配置（タップ＆ドラッグ） ===== */ 
let placing = null;
let placingCell = null;
let selectedTower = null;

$('#palette').addEventListener('pointerdown', (e)=>{ 
  const btn = e.target.closest('.item'); 
  if(!btn) return; 
  e.preventDefault(); 
  const idx = +btn.dataset.index; 
  const item = ITEMS[idx]; 
  startPlacing(item, e); 
});

// グリッドタップでも配置可能
gridEl.addEventListener('pointerdown', (e)=>{ 
  if(!placing) {
    // タワー選択モード
    const r = gridEl.getBoundingClientRect(); 
    const gx = clamp(Math.floor((e.clientX - r.left)/TILE()), 0, GRID_W-1); 
    const gy = clamp(Math.floor((e.clientY - r.top)/TILE()), 0, GRID_H-1);
    
    // タワーがここにあるか確認
    const tower = state.towers.find(t => t.x === gx && t.y === gy);
    if (tower) {
      selectTower(tower);
      e.preventDefault();
      return;
    }
    
    // ユニットがここにあるか確認
    const unit = state.units.find(u => u.x === gx && u.y === gy);
    if (unit) {
      showHint(`ユニット: ${unit.hp}/${unit.hpMax}HP`, e.clientX, e.clientY);
      e.preventDefault();
      return;
    }
    
    return; 
  }
  
  e.preventDefault(); 
  const r = gridEl.getBoundingClientRect(); 
  const gx = clamp(Math.floor((e.clientX - r.left)/TILE()), 0, GRID_W-1); 
  const gy = clamp(Math.floor((e.clientY - r.top)/TILE()), 0, GRID_H-1); 
  placingCell = {x:gx,y:gy}; 
  tryPlace(placing.item, gx, gy); 
  cancelPlacing(); 
});

// タワー選択機能
function selectTower(tower) {
  selectedTower = tower;
  showUpgradeUI(tower);
}

function showUpgradeUI(tower) {
  const ui = $('#upgradeUI');
  ui.innerHTML = '';
  
  const item = ITEMS.find(it => it.key === tower.key);
  if (!item || !item.upgrades) return;
  
  const x = tower.x * TILE() + TILE()/2;
  const y = tower.y * TILE() + TILE()/2;
  
  ui.style.left = x + 'px';
  ui.style.top = (y - 80) + 'px';
  ui.style.display = 'block';
  
  const level = tower.level || 1;
  const maxLevel = item.upgrades;
  
  if (level < maxLevel) {
    const upgradeCost = Math.round(item.cost * 0.7 * level);
    const upgradeOption = document.createElement('div');
    upgradeOption.className = 'upgrade-option';
    upgradeOption.innerHTML = `
      <span>Lv.${level}→${level+1}</span>
      <button class="upgrade-btn" data-cost="${upgradeCost}">💰${upgradeCost}</button>
    `;
    ui.appendChild(upgradeOption);
    
    upgradeOption.querySelector('.upgrade-btn').addEventListener('click', () => {
      if (state.money >= upgradeCost) {
        upgradeTower(tower, upgradeCost);
        ui.style.display = 'none';
      } else {
        toast('お金が足りません');
      }
    });
  } else {
    const maxLevelInfo = document.createElement('div');
    maxLevelInfo.className = 'upgrade-option';
    maxLevelInfo.textContent = `最大レベル Lv.${maxLevel}`;
    ui.appendChild(maxLevelInfo);
  }
  
  // 売却オプション
  const sellOption = document.createElement('div');
  sellOption.className = 'upgrade-option';
  const sellValue = Math.round(item.cost * 0.6 * (tower.level || 1));
  sellOption.innerHTML = `
    <span>売却</span>
    <button class="upgrade-btn" style="background:var(--bad)">💰${sellValue}</button>
  `;
  ui.appendChild(sellOption);
  
  sellOption.querySelector('.upgrade-btn').addEventListener('click', () => {
    sellTower(tower, sellValue);
    ui.style.display = 'none';
  });
}

function upgradeTower(tower, cost) {
  state.money -= cost;
  refreshStats();
  
  if (!tower.level) tower.level = 1;
  tower.level++;
  
  // アップグレード効果
  tower.dmg = Math.round(tower.dmg * 1.4);
  tower.range *= 1.1;
  tower.rof *= 1.1;
  
  // 見た目の更新
  if (tower.level > 1) {
    if (!tower.el.querySelector('.upgrade-indicator')) {
      const indicator = document.createElement('div');
      indicator.className = 'upgrade-indicator';
      tower.el.appendChild(indicator);
    }
  }
  
  toast(`タワーをLv.${tower.level}にアップグレードしました`);
  SE.upgrade();
}

function sellTower(tower, value) {
  state.money += value;
  refreshStats();
  
  // マップから削除
  map[tower.y][tower.x] = 0;
  
  // 状態から削除
  const index = state.towers.indexOf(tower);
  if (index > -1) {
    state.towers.splice(index, 1);
  }
  
  // 要素を削除
  tower.el.remove();
  
  // 経路再計算
  currentPath = astar(START, GOAL, map);
  paintPath(currentPath);
  
  toast(`タワーを売却して💰${value}を獲得`);
  SE.sell();
}

// アップグレードUIを閉じる
document.addEventListener('pointerdown', (e) => {
  if (!e.target.closest('.upgrade-ui') && $('#upgradeUI').style.display === 'block') {
    $('#upgradeUI').style.display = 'none';
  }
});

function startPlacing(item, e){ 
  if(state.paused){ toast('一時停止中'); return; } 
  if(state.money < item.cost){ toast('お金が足りません'); return; } 
  $$('.item').forEach(x=>x.classList.remove('sel')); 
  const src = $(`.item[data-key="${item.key}"]`); 
  if(src) src.classList.add('sel'); 
  const g=document.createElement('div'); 
  g.className='ghost'; 
  const size = item.kind==='trap' && item.key==='trap_slow' ? 34 : 30; 
  g.style.width = size+'px'; 
  g.style.height = size+'px'; 
  gridEl.appendChild(g); 
  
  // 範囲表示円の追加
  const rangeCircle = document.createElement('div');
  rangeCircle.className = 'range-circle';
  const range = (item.range || 0) * TILE();
  rangeCircle.style.width = range*2 + 'px';
  rangeCircle.style.height = range*2 + 'px';
  g.appendChild(rangeCircle);
  
  placing = { item, ghostEl:g }; 
  moveGhost(e);

  window.addEventListener('pointermove', moveGhost);
  window.addEventListener('pointerup', endPlacing, { once:true });
  window.addEventListener('pointercancel', cancelPlacing, { once:true });
} 

function moveGhost(e){ 
  if(!placing) return; 
  const r = gridEl.getBoundingClientRect(); 
  const clientX = e.clientX ?? (e.touches && e.touches[0]?.clientX); 
  const clientY = e.clientY ?? (e.touches && e.touches[0]?.clientY); 
  if(clientX==null || clientY==null) return; 
  const gx = clamp(Math.floor((clientX - r.left)/TILE()), 0, GRID_W-1); 
  const gy = clamp(Math.floor((clientY - r.top)/TILE()), 0, GRID_H-1); 
  placingCell = {x:gx,y:gy}; 
  const cx = gx*TILE() + TILE()/2; 
  const cy = gy*TILE() + TILE()/2; 
  placing.ghostEl.style.left = cx+'px'; 
  placing.ghostEl.style.top = cy+'px'; 
  
  // 配置可能かどうかの色フィードバック
  if (cellBlockedForPlacement(gx, gy)) {
    placing.ghostEl.style.borderColor = '#ef444455';
    placing.ghostEl.style.background = '#ef444410';
  } else {
    placing.ghostEl.style.borderColor = '#93c5fd55';
    placing.ghostEl.style.background = '#60a5fa10';
  }
} 

function endPlacing(e){ 
  window.removeEventListener('pointermove', moveGhost); 
  if(!placingCell){ cancelPlacing(); return; } 
  tryPlace(placing.item, placingCell.x, placingCell.y); 
  cancelPlacing(); 
} 

function cancelPlacing(){ 
  if(placing){ 
    placing.ghostEl.remove(); 
    placing=null; 
  } 
  $$('.item').forEach(x=>x.classList.remove('sel')); 
} 

function cellBlockedForPlacement(x,y){ 
  if((x===START.x&&y===START.y) || (x===GOAL.x&&y===GOAL.y)) return true; 
  if(map[y][x]===1) return true; 
  return false; 
} 

function tryPlace(item, x, y){ 
  if(cellBlockedForPlacement(x,y)){ toast('ここには置けません'); return; }

  const temp = map.map(row=>row.slice());
  if(item.kind==='trap'){
    if(item.key==='trap_slow'){
      if(temp[y][x]!==0) { toast('ここには置けません'); return; }
      temp[y][x]=2;
    }else if(item.key==='trap_mine'){
      if(temp[y][x]!==0) { toast('ここには置けません'); return; }
      temp[y][x]=3;
    }
  }else{
    if(temp[y][x]!==0) { toast('ここには置けません'); return; }
    temp[y][x]=4;
  }

  const p = astar(START, GOAL, temp);
  if(!p){ toast('経路をふさげません'); return; }

  if(state.money < item.cost){ toast('お金が足りません'); return; }
  state.money -= item.cost; 
  refreshStats();

  if(item.kind==='trap'){
    if(item.key==='trap_slow'){ map[y][x]=2; spawnTrap(x,y,'slow',item); }
    else { map[y][x]=3; spawnTrap(x,y,'mine',item); }
    SE.place();
  }else if(item.kind==='tower'){
    map[y][x]=4; spawnTower(x,y,item); 
    SE.place();
  }else if(item.kind==='unit'){
    map[y][x]=4; spawnUnit(x,y,item); 
    SE.place();
  }

  currentPath = p; 
  paintPath(currentPath);
}

/* ===== エンティティ生成 ===== */
function placeEntityEl(cls, x, y){ 
  const el=document.createElement('div'); 
  el.className='entity '+cls; 
  el.style.left = (x*TILE() + TILE()/2)+'px'; 
  el.style.top  = (y*TILE() + TILE()/2)+'px'; 
  gridEl.appendChild(el); 
  return el; 
}

function spawnTower(x,y,item){ 
  const el = placeEntityEl(item.iconClass, x,y); 
  const o = { 
    kind:'tower', 
    key: item.key,
    x, y, 
    px:x*TILE()+TILE()/2, 
    py:y*TILE()+TILE()/2, 
    range:item.range*TILE(), 
    dmg:item.dmg, 
    rof:item.rof, 
    cd:0, 
    el,
    splash: item.splash || 0
  }; 
  state.towers.push(o); 
} 

function spawnUnit(x,y,item){ 
  const el = placeEntityEl(item.iconClass, x,y); 
  const o = { 
    kind:'unit', 
    x, y, 
    px:x*TILE()+TILE()/2, 
    py:y*TILE()+TILE()/2, 
    range:item.range*TILE(), 
    dmg:item.dmg, 
    rof:item.rof, 
    cd:0, 
    el,
    hp: item.hp,
    hpMax: item.hp
  }; 
  
  // ユニット用HPバーの追加
  const healthBar = document.createElement('div');
  healthBar.className = 'health-bar';
  const healthFill = document.createElement('div');
  healthFill.className = 'health-fill';
  healthBar.appendChild(healthFill);
  el.appendChild(healthBar);
  
  state.units.push(o); 
} 

function spawnTrap(x,y,type,item){ 
  const el = placeEntityEl(type==='slow'?'trap slow':'trap mine', x,y); 
  state.traps.push({
    x,y,type,
    slow:item.slow??0.55, 
    duration: item.duration || 0,
    used:false, 
    el
  }); 
}

function spawnEnemy(type){ 
  const base = ENEMY_BASE[type]; 
  const el = placeEntityEl(base.class, START.x, START.y); 
  const hpMax = Math.ceil(base.hp * DIFFS[state.diff].enemyHP);
  const o = { 
    type, el, 
    hp:hpMax, 
    hpMax,
    spd:base.spd * DIFFS[state.diff].enemySpd, 
    reward: Math.round(base.reward * DIFFS[state.diff].reward), 
    dmg:base.dmg,
    path: currentPath.slice(), 
    pathIndex:0, 
    x: START.x*TILE()+TILE()/2, 
    y: START.y*TILE()+TILE()/2, 
    slowTimer:0,
    frozen: false
  }; 
  
  // 敵用HPバーの追加 (bossとeliteのみ)
  if (type === 'boss' || type === 'elite') {
    const healthBar = document.createElement('div');
    healthBar.className = 'health-bar';
    const healthFill = document.createElement('div');
    healthFill.className = 'health-fill';
    healthBar.appendChild(healthFill);
    el.appendChild(healthBar);
  }
  
  state.enemies.push(o); 
}

function fire(from, to, isRocket = false){ 
  const cls = isRocket ? 'rocket' : 'bullet';
  const el = placeEntityEl(cls, from.px/ TILE(), from.py/ TILE()); 
  const projectile = { 
    el, 
    x:from.px, 
    y:from.py, 
    tx:to.x, 
    ty:to.y, 
    spd: isRocket ? 320 : 480, 
    dmg: from.dmg,
    splash: from.splash || 0
  }; 
  
  if (isRocket) {
    state.rockets.push(projectile);
  } else {
    state.bullets.push(projectile);
  }
  
  SE.shoot();
}

function createLaser(from, to) {
  const dx = to.x - from.px;
  const dy = to.y - from.py;
  const dist = Math.sqrt(dx*dx + dy*dy);
  const angle = Math.atan2(dy, dx);
  
  const el = document.createElement('div');
  el.className = 'laser';
  el.style.left = from.px + 'px';
  el.style.top = from.py + 'px';
  el.style.width = dist + 'px';
  el.style.transform = `rotate(${angle}rad)`;
  gridEl.appendChild(el);
  
  // レーザーエフェクト
  setTimeout(() => {
    el.remove();
  }, 100);
}

/* ===== 特殊能力 ===== */
function useSkill(skillName, x, y) {
  const skill = state.skills[skillName];
  
  if (state.money < skill.cost || skill.cooldownLeft > 0) {
    return false;
  }
  
  state.money -= skill.cost;
  refreshStats();
  skill.cooldownLeft = skill.cooldown;
  
  switch(skillName) {
    case 'airStrike':
      // 空爆支援
      const targets = state.enemies.filter(e => {
        const dx = e.x - x;
        const dy = e.y - y;
        return Math.sqrt(dx*dx + dy*dy) < 100; // 爆発範囲
      });
      
      targets.forEach(e => {
        e.hp -= 100;
        if (e.hp <= 0) {
          state.money += e.reward;
          state.score += e.reward * 2;
        }
      });
      
      // 爆発エフェクト
      const explosion = document.createElement('div');
      explosion.className = 'explosion';
      explosion.style.left = x + 'px';
      explosion.style.top = y + 'px';
      gridEl.appendChild(explosion);
      
      setTimeout(() => {
        explosion.remove();
      }, 500);
      
      SE.explosion();
      toast('空爆支援を実行！');
      break;
      
    case 'freeze':
      // 時間停止
      state.skills.freeze.active = true;
      state.freezeTime = 5; // 5秒間凍結
      
      state.enemies.forEach(e => {
        e.frozen = true;
        e.el.style.filter = 'brightness(0.5) hue-rotate(180deg)';
      });
      
      toast('時間停止発動！');
      SE.freeze();
      break;
  }
  
  return true;
}

// スキルボタンのイベント
$('#btnSkill1').addEventListener('click', () => {
  placingSkill = 'airStrike';
  toast('爆撃地点をタップで選択', 2500);
});

$('#btnSkill2').addEventListener('click', () => {
  useSkill('freeze');
});

// スキルターゲット選択
let placingSkill = null;
gridEl.addEventListener('click', (e) => {
  if (!placingSkill) return;
  
  const r = gridEl.getBoundingClientRect();
  const x = e.clientX - r.left;
  const y = e.clientY - r.top;
  
  useSkill(placingSkill, x, y);
  placingSkill = null;
});

/* ===== ウェーブ管理 ===== */ 
let waveTimer=0, spawnQueue=[]; 
function setupWave(n){ 
  state.wave = n; 
  refreshStats(); 
  
  // エンドレスモードの場合、ウェーブをループする
  const waveIndex = Math.min(n-1, WAVES.length-1);
  const conf = WAVES[waveIndex]; 
  spawnQueue = []; 
  const mult = DIFFS[state.diff].enemyNum; 
  for(const e of conf.list){ 
    const count = Math.round(e.n * mult); 
    for(let i=0;i<count;i++) spawnQueue.push({type:e.type, at: (spawnQueue.at(-1)?.at??0) + e.gap}); 
  } 
  waveTimer = 0; 
} 

let intermission = true;

function startWave(){ 
  if(state.wave>=MODES[state.mode].waves && !MODES[state.mode].endless){ 
    return; 
  } 
  intermission=false; 
  setupWave(state.wave+1); 
  toast(`Wave ${state.wave} 開始!`); 
  SE.wave();
} 

function endWave(){ 
  const bonus = Math.round(40 * DIFFS[state.diff].reward); 
  state.money += bonus; 
  state.score += bonus * 5;
  refreshStats(); 
  toast(`Wave ${state.wave} クリア！ +💰${bonus}`); 
  intermission=true; 
  
  if(state.wave>=MODES[state.mode].waves && !MODES[state.mode].endless){ 
    victory(); 
  } 
} 

function victory(){ 
  state.running=false; 
  BGM.stop(); 
  
  // スコア計算
  const timeBonus = Math.round(1000 * (state.wave / 10));
  const lifeBonus = state.life * 50;
  const totalScore = state.score + timeBonus + lifeBonus;
  
  // ハイスコア更新
  const isNewHighScore = setHighScore(totalScore);
  
  showResult(true, totalScore, timeBonus, lifeBonus, isNewHighScore); 
} 

function defeat(){ 
  state.running=false; 
  BGM.stop(); 
  showResult(false, state.score, 0, 0, false); 
} 

function showResult(win, score, timeBonus, lifeBonus, isNewHighScore){ 
  const res = $('#result'); 
  $('#resultTitle').textContent = win? '勝利！':'敗北…'; 
  $('#resultStats').textContent = `到達Wave: ${state.wave} / 所持金: ${state.money} / スコア: ${score}`;
  
  if (win) {
    $('#resultStats').textContent += `\nタイムボーナス: +${timeBonus} / ライフボーナス: +${lifeBonus}`;
  }
  
  const highScoreEl = $('#highScore');
  highScoreEl.innerHTML = `ハイスコア: ${getHighScore()}`;
  if (isNewHighScore) {
    highScoreEl.innerHTML += '<br><span style="color:var(--warn)">🎉 ニューハイスコア！</span>';
  }
  
  res.classList.add('show'); 
}

/* ===== 簡易オーディオ ===== */
const AudioKit = (()=>{ 
  let ctx=null; 
  let gain; 
  function init(){ 
    if(ctx) return; 
    ctx=new (window.AudioContext||window.webkitAudioContext)(); 
    gain=ctx.createGain(); 
    gain.gain.value=0.2; 
    gain.connect(ctx.destination); 
  } 
  function beep(freq=440, dur=0.07, type='square', vol=0.25){ 
    if(!ctx) return; 
    const o=ctx.createOscillator(); 
    const g=ctx.createGain(); 
    o.type=type; 
    o.frequency.value=freq; 
    o.connect(g); 
    g.gain.value=vol; 
    g.connect(gain); 
    o.start(); 
    o.stop(ctx.currentTime+dur); 
  } 
  return { init, beep, get ctx(){return ctx;}, gain(){return gain;} }; 
})(); 

const SE = { 
  place: ()=>AudioKit.beep(520,0.06,'triangle',0.18), 
  shoot: ()=>AudioKit.beep(880,0.03,'square',0.12), 
  hit:   ()=>AudioKit.beep(240,0.05,'sine',0.2),
  explosion: ()=>AudioKit.beep(120,0.3,'sawtooth',0.3),
  freeze: ()=>AudioKit.beep(640,0.2,'sine',0.25),
  upgrade: ()=>AudioKit.beep(640,0.1,'sine',0.2),
  sell: ()=>AudioKit.beep(320,0.1,'sine',0.2),
  wave: ()=>AudioKit.beep(440,0.2,'sine',0.3),
  laser: ()=>{
    AudioKit.beep(960,0.1,'sine',0.15);
    AudioKit.beep(720,0.1,'sine',0.1);
  }
};

// BGM
const BGM = (() => {
  let audio = null;
  return {
    play: () => {
      if (audio) return;
      // 簡易BGM（実際のゲームでは適切なBGMファイルを使用）
      audio = new Audio();
      audio.loop = true;
      audio.volume = 0.3;
      // 実際のプロジェクトではBGMファイルを追加
      console.log("BGM would play here");
    },
    stop: () => {
      if (audio) {
        audio.pause();
        audio = null;
      }
    }
  };
})();

/* ===== ゲームループ ===== */ 
let currentPath = null; 
let lastTime = 0; 
let accuTime = 0; 

function gameLoop(timestamp){ 
  if(!lastTime) lastTime = timestamp; 
  const delta = (timestamp - lastTime) / 1000; 
  lastTime = timestamp; 
  
  if(state.paused) return requestAnimationFrame(gameLoop);
  
  accuTime += delta * state.speed;
  
  // スキルクールダウン更新
  for (const skillName in state.skills) {
    if (state.skills[skillName].cooldownLeft > 0) {
      state.skills[skillName].cooldownLeft -= delta;
      if (state.skills[skillName].cooldownLeft < 0) {
        state.skills[skillName].cooldownLeft = 0;
      }
    }
  }
  
  // 凍結効果の更新
  if (state.skills.freeze.active) {
    state.freezeTime -= delta;
    if (state.freezeTime <= 0) {
      state.skills.freeze.active = false;
      state.enemies.forEach(e => {
        e.frozen = false;
        e.el.style.filter = '';
      });
    }
  }
  
  // ウェーブ管理
  if(state.running){ 
    if(intermission){ 
      if(state.enemies.length===0){ 
        // ウェーブ間の小休止
        if(accuTime > 5){ 
          accuTime = 0; 
          startWave(); 
        } 
      } 
    }else{ 
      waveTimer += delta; 
      
      // 敵スポーン
      while(spawnQueue.length && spawnQueue[0].at < waveTimer){ 
        const next = spawnQueue.shift(); 
        spawnEnemy(next.type); 
      } 
      
      if(spawnQueue.length===0 && state.enemies.length===0){ 
        endWave(); 
      } 
    } 
  } 
  
  // タワーの動作
  state.towers.forEach(tower=>{ 
    tower.cd -= delta; 
    if(tower.cd <= 0){ 
      // 最も近い敵を探す
      let closest = null; 
      let minDist = Infinity; 
      state.enemies.forEach(e=>{ 
        const dx = e.x - tower.px; 
        const dy = e.y - tower.py; 
        const dist = Math.sqrt(dx*dx+dy*dy); 
        if(dist < tower.range && dist < minDist){ 
          minDist = dist; 
          closest = e; 
        } 
      }); 
      if(closest){ 
        tower.cd = 1/tower.rof; 
        if (tower.key === 'tower_sniper') {
          createLaser(tower, closest);
          SE.laser();
        }
        fire(tower, closest, tower.key === 'tower_rocket'); 
      } 
    } 
  }); 
  
  // ユニットの動作
  state.units.forEach(unit=>{ 
    unit.cd -= delta; 
    if(unit.cd <= 0){ 
      let closest = null; 
      let minDist = Infinity; 
      state.enemies.forEach(e=>{ 
        const dx = e.x - unit.px; 
        const dy = e.y - unit.py; 
        const dist = Math.sqrt(dx*dx+dy*dy); 
        if(dist < unit.range && dist < minDist){ 
          minDist = dist; 
          closest = e; 
        } 
      }); 
      if(closest){ 
        unit.cd = 1/unit.rof; 
        fire(unit, closest); 
      } 
    } 
  }); 
  
  // 弾丸の移動
  state.bullets.forEach((b,i)=>{ 
    const dx = b.tx - b.x; 
    const dy = b.ty - b.y; 
    const dist = Math.sqrt(dx*dx+dy*dy); 
    const move = b.spd * delta; 
    if(move >= dist){ 
      // 命中
      b.el.remove(); 
      state.bullets.splice(i,1); 
      state.enemies.forEach(e=>{ 
        if(Math.abs(e.x - b.tx) < 5 && Math.abs(e.y - b.ty) < 5){ 
          e.hp -= b.dmg; 
          SE.hit();
          if(e.hp <= 0){ 
            state.money += e.reward; 
            state.score += e.reward;
            e.el.remove(); 
            state.enemies.splice(state.enemies.indexOf(e),1); 
          } 
        } 
      }); 
    }else{ 
      b.x += dx/dist * move; 
      b.y += dy/dist * move; 
      b.el.style.left = b.x+'px'; 
      b.el.style.top = b.y+'px'; 
    } 
  }); 
  
  // ロケットの移動と爆発
  state.rockets.forEach((r,i)=>{ 
    const dx = r.tx - r.x; 
    const dy = r.ty - r.y; 
    const dist = Math.sqrt(dx*dx+dy*dy); 
    const move = r.spd * delta; 
    if(move >= dist){ 
      // 爆発
      r.el.remove(); 
      state.rockets.splice(i,1); 
      
      // 範囲ダメージ
      state.enemies.forEach(e=>{ 
        const edx = e.x - r.tx; 
        const edy = e.y - r.ty; 
        const edist = Math.sqrt(edx*edx+edy*edy); 
        if(edist < r.splash * TILE()){ 
          // 距離に応じたダメージ減衰
          const damage = r.dmg * (1 - edist/(r.splash * TILE()));
          e.hp -= damage; 
          SE.hit();
          if(e.hp <= 0){ 
            state.money += e.reward; 
            state.score += e.reward;
            e.el.remove(); 
            state.enemies.splice(state.enemies.indexOf(e),1); 
          } 
        } 
      }); 
      
      // 爆発エフェクト
      const explosion = document.createElement('div');
      explosion.className = 'explosion';
      explosion.style.left = r.tx + 'px';
      explosion.style.top = r.ty + 'px';
      gridEl.appendChild(explosion);
      
      setTimeout(() => {
        explosion.remove();
      }, 500);
      
      SE.explosion();
    }else{ 
      r.x += dx/dist * move; 
      r.y += dy/dist * move; 
      r.el.style.left = r.x+'px'; 
      r.el.style.top = r.y+'px'; 
      
      // ロケットの回転
      const angle = Math.atan2(dy, dx);
      r.el.style.transform = `translate(-50%, -50%) rotate(${angle}rad)`;
    } 
  }); 
  
  // 敵の移動
  state.enemies.forEach(e=>{ 
    if (e.frozen) return; // 凍結中は移動しない
    
    if(e.pathIndex < e.path.length){ 
      const next = e.path[e.pathIndex]; 
      const tx = next.x*TILE() + TILE()/2; 
      const ty = next.y*TILE() + TILE()/2; 
      const dx = tx - e.x; 
      const dy = ty - e.y; 
      const dist = Math.sqrt(dx*dx+dy*dy); 
      
      let speed = e.spd * TILE() * delta;
      
      // 減速トラップの効果
      if (e.slowTimer > 0) {
        speed *= 0.5;
        e.slowTimer -= delta;
      }
      
      if(speed >= dist){ 
        e.x = tx; 
        e.y = ty; 
        e.pathIndex++; 
      }else{ 
        e.x += dx/dist * speed; 
        e.y += dy/dist * speed; 
      } 
      e.el.style.left = e.x+'px'; 
      e.el.style.top = e.y+'px'; 
      
      // ゴール到達チェック
      if(e.pathIndex >= e.path.length){ 
        state.life -= e.dmg; 
        refreshStats(); 
        e.el.remove(); 
        state.enemies.splice(state.enemies.indexOf(e),1); 
        if(state.life <= 0){ 
          defeat(); 
        } 
      } 
    } 
    
    // HPバーの更新 (bossとeliteのみ)
    if ((e.type === 'boss' || e.type === 'elite') && e.el.querySelector('.health-fill')) {
      const healthFill = e.el.querySelector('.health-fill');
      healthFill.style.width = `${(e.hp / e.hpMax) * 100}%`;
    }
  }); 
  
  // ユニットのHPバー更新
  state.units.forEach(u => {
    if (u.el.querySelector('.health-fill')) {
      const healthFill = u.el.querySelector('.health-fill');
      healthFill.style.width = `${(u.hp / u.hpMax) * 100}%`;
    }
  });
  
  // トラップの処理
  state.traps.forEach((trap, index)=>{ 
    if(trap.used) return; 
    state.enemies.forEach(e=>{ 
      const dx = e.x - (trap.x*TILE()+TILE()/2); 
      const dy = e.y - (trap.y*TILE()+TILE()/2); 
      const dist = Math.sqrt(dx*dx+dy*dy); 
      if(dist < TILE()/2){ 
        if(trap.type==='mine'){ 
          e.hp -= 50; 
          if(e.hp <= 0){ 
            state.money += e.reward; 
            state.score += e.reward;
            e.el.remove(); 
            state.enemies.splice(state.enemies.indexOf(e),1); 
          } 
          trap.used = true; 
          trap.el.remove(); 
          state.traps.splice(index,1); 
          
          // 地雷爆発エフェクト
          const explosion = document.createElement('div');
          explosion.className = 'explosion';
          explosion.style.left = e.x + 'px';
          explosion.style.top = e.y + 'px';
          explosion.style.width = '40px';
          explosion.style.height = '40px';
          gridEl.appendChild(explosion);
          
          setTimeout(() => {
            explosion.remove();
          }, 500);
          
          SE.explosion();
        }else if(trap.type==='slow'){ 
          e.slowTimer = trap.duration; 
          trap.used = true; 
          trap.el.remove(); 
          state.traps.splice(index,1); 
        } 
      } 
    }); 
  }); 
  
  requestAnimationFrame(gameLoop); 
} 

/* ===== 初期化 ===== */ 
function initGame(){ 
  AudioKit.init(); 
  BGM.play();
  
  state.running=true; 
  state.paused=false; 
  state.money = DIFFS[state.diff].startMoney; 
  state.life = DIFFS[state.diff].life; 
  state.wave = 0; 
  state.score = 0;
  state.enemies = []; 
  state.towers = []; 
  state.units = []; 
  state.traps = []; 
  state.bullets = []; 
  state.rockets = [];
  
  // スキルクールダウンリセット
  for (const skillName in state.skills) {
    state.skills[skillName].cooldownLeft = 0;
    state.skills[skillName].active = false;
  }
  state.freezeTime = 0;
  
  // マップ再生成
  const newMap = generateMap();
  for (let y = 0; y < GRID_H; y++) {
    for (let x = 0; x < GRID_W; x++) {
      map[y][x] = newMap[y][x];
    }
  }
  
  renderGrid(); 
  buildPalette(); 
  refreshStats(); 
  
  currentPath = astar(START, GOAL); 
  paintPath(currentPath); 
  
  lastTime = 0; 
  accuTime = 0; 
  intermission = true; 
  
  requestAnimationFrame(gameLoop); 
} 

// UIイベント
$('#btnStartGame').addEventListener('click', ()=>{ 
  $('#overlay').classList.remove('show'); 
  initGame(); 
}); 

$('#btnBackTitle').addEventListener('click', ()=>{ 
  $('#result').classList.remove('show'); 
  $('#overlay').classList.add('show'); 
}); 

$('#btnRestart').addEventListener('click', ()=>{ 
  $('#result').classList.remove('show'); 
  initGame(); 
}); 

$('#btnStartWave').addEventListener('click', startWave); 

$('#btnPause').addEventListener('click', ()=>{ 
  state.paused = !state.paused; 
  $('#btnPause').textContent = state.paused ? '再開' : '一時停止'; 
  $('#btnPause').classList.toggle('primary', !state.paused);
  $('#btnPause').classList.toggle('warning', state.paused);
}); 

$('#btnSpeed').addEventListener('click', ()=>{ 
  state.speed = state.speed % 3 + 1; 
  $('#btnSpeed').textContent = `速度×${state.speed}`; 
}); 

// 難易度選択
$$('#difficulty .chip').forEach(chip=>{ 
  chip.addEventListener('click', ()=>{ 
    $$('#difficulty .chip').forEach(c=>c.classList.remove('sel')); 
    chip.classList.add('sel'); 
    state.diff = chip.dataset.diff; 
  }); 
}); 

// ゲームモード選択
$$('#gameMode .chip').forEach(chip=>{ 
  chip.addEventListener('click', ()=>{ 
    $$('#gameMode .chip').forEach(c=>c.classList.remove('sel')); 
    chip.classList.add('sel'); 
    state.mode = chip.dataset.mode; 
  }); 
}); 

// 初期レンダリング
renderGrid(); 
buildPalette(); 
})(); 
</script>
</body>
</html>
