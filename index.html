<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Mobile TD v0.1 â€” è¿·è·¯å‹ã‚¿ãƒ¯ãƒ¼ãƒ‡ã‚£ãƒ•ã‚§ãƒ³ã‚¹ï¼ˆç¾ä»£ãƒŸãƒªã‚¿ãƒªãƒ¼ï¼‰</title>
  <meta name="description" content="ã‚¹ãƒãƒ›å‘ã‘ï¼šè¿·è·¯å‹ã‚¿ãƒ¯ãƒ¼ãƒ‡ã‚£ãƒ•ã‚§ãƒ³ã‚¹ã€‚ã‚¿ãƒƒãƒ—ï¼†ãƒ‰ãƒ©ãƒƒã‚°ã§é…ç½®ã€å…¨10ã‚¦ã‚§ãƒ¼ãƒ–ã€é˜²è¡›ã§ããŸã‚‰å‹ã¡ã€‚" />
  <style>
    :root{
      --bg:#0b0f14; --panel:#0f1520; --ink:#e6edf3; --muted:#93a0ad; --ok:#10b981; --warn:#f59e0b; --bad:#ef4444;
      --bar: 104px; /* ä¸‹éƒ¨UIãƒãƒ¼ã®é«˜ã• */
      --tile: 44px; /* ã‚¿ã‚¤ãƒ«ã‚µã‚¤ã‚ºï¼ˆã‚¹ãƒãƒ›æƒ³å®šï¼‰ */
      --grid-w: 12; /* æ¨ªãƒã‚¹æ•° */
      --grid-h: 16; /* ç¸¦ãƒã‚¹æ•°ï¼ˆä¸‹éƒ¨ãƒãƒ¼ãŒã‚ã‚‹ã®ã§ç¸¦ã¯é•·ã‚ï¼‰ */
    }
    *{box-sizing:border-box;touch-action:manipulation}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans JP","Hiragino Kaku Gothic ProN","Yu Gothic",Meiryo,sans-serif}
    #wrap{min-height:100%;display:grid;grid-template-rows:1fr auto;}

    /* ====== ãƒ—ãƒ¬ã‚¤ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ ====== */
    #fieldWrap{position:relative;overflow:hidden;border-bottom:1px solid #1f2937}
    #grid{position:relative;display:grid;grid-template-columns:repeat(var(--grid-w), var(--tile));grid-template-rows:repeat(var(--grid-h), var(--tile));
      width:calc(var(--grid-w) * var(--tile));height:calc(var(--grid-h) * var(--tile));margin:0 auto;}
    .cell{width:var(--tile);height:var(--tile);border:1px solid #0f172a;background:#0b1220}
    .cell.path{background:#0c253c}
    .cell.start{background:#134e4a}
    .cell.goal{background:#4a1313}

    /* ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ï¼ˆDOMè¦ç´ ï¼‰ */
    .entity{position:absolute;pointer-events:none;translate:-50% -50%;}
    .enemy{width:28px;height:28px;border-radius:6px;background:#ef4444;box-shadow:0 0 0 2px rgba(0,0,0,.25)}
    .enemy.tank{width:34px;height:34px;background:#b91c1c}
    .enemy.bike{width:24px;height:24px;background:#f97316}
    .enemy.boss{width:46px;height:46px;background:#7f1d1d;outline:3px solid #fecaca}

    .tower,.unit{width:30px;height:30px;border-radius:4px;background:#60a5fa;border:2px solid #1d4ed8}
    .tower.sniper{background:#a78bfa;border-color:#6d28d9}
    .tower.mg{background:#34d399;border-color:#059669}
    .unit.infantry{background:#f59e0b;border-color:#b45309}
    .unit.vehicle{background:#cbd5e1;border-color:#475569}
    .trap.mine{width:22px;height:22px;border-radius:50%;background:#f43f5e;border:2px dashed #7f1d1d}
    .trap.slow{width:34px;height:34px;border-radius:6px;background:#1e293b80;border:2px solid #334155}

    .bullet{width:6px;height:6px;border-radius:50%;background:#eab308}

    /* å½±éŸ¿ç¯„å›²ã®ã‚´ãƒ¼ã‚¹ãƒˆ */
    .ghost{position:absolute;pointer-events:none;border:2px dashed #93c5fd55;border-radius:10px;background:#60a5fa10;translate:-50% -50%;}

    /* ====== ä¸‹éƒ¨UIãƒãƒ¼ ====== */
    #bar{position:relative;background:var(--panel);padding:8px 10px calc(8px + env(safe-area-inset-bottom));display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center;min-height:var(--bar);}
    #stats{display:flex;gap:12px;align-items:center;font-size:14px;color:var(--muted)}
    #stats b{color:var(--ink)}
    #palette{display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end}
    .item{display:flex;flex-direction:column;align-items:center;gap:4px;background:#111827;border:1px solid #1f2937;padding:6px 8px;border-radius:10px;min-width:62px}
    .item.sel{outline:2px solid #60a5fa}
    .item .ico{width:28px;height:28px;border-radius:6px}
    .item .name{font-size:12px;color:#cbd5e1}
    .item .cost{font-size:11px;color:#9aa4b2}

    /* ã‚¹ã‚¿ãƒ¼ãƒˆ/ãƒãƒ¼ã‚ºãªã© */
    #ctrls{position:absolute;left:10px;top:10px;display:flex;gap:8px;z-index:3}
    .btn{appearance:none;border:none;border-radius:999px;background:#1f2937;color:#e5e7eb;padding:8px 12px;font-size:12px}
    .btn:active{transform:translateY(1px)}

    /* ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ï¼ˆã‚¿ã‚¤ãƒˆãƒ«/é›£æ˜“åº¦/ãƒªã‚¶ãƒ«ãƒˆï¼‰ */
    .overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.55);z-index:5}
    .overlay.show{display:flex}
    .panel{background:#0f1520;border:1px solid #1f2937;border-radius:16px;max-width:520px;width:92%;padding:16px}
    .panel h1{font-size:20px;margin:0 0 8px}
    .panel h2{font-size:16px;margin:10px 0 6px;color:#cbd5e1}
    .panel p{margin:4px 0;color:#9aa4b2}
    .row{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    .chip{border:1px solid #374151;background:#111827;color:#e5e7eb;padding:8px 12px;border-radius:999px;font-size:14px}
    .chip.sel{outline:2px solid #60a5fa}

    /* ãƒˆãƒ¼ã‚¹ãƒˆ */
    #toast{position:absolute;left:50%;top:14px;transform:translateX(-50%);background:#111827;border:1px solid #1f2937;color:#e5e7eb;border-radius:999px;padding:8px 14px;font-size:13px;opacity:0;transition:opacity .2s;z-index:6}
    #toast.show{opacity:1}
  </style>
</head>
<body>
  <div id="wrap">
    <div id="fieldWrap">
      <div id="ctrls">
        <button class="btn" id="btnStartWave">Waveé–‹å§‹</button>
        <button class="btn" id="btnPause">ä¸€æ™‚åœæ­¢</button>
        <button class="btn" id="btnSpeed">é€Ÿåº¦Ã—1</button>
      </div>
      <div id="grid" aria-label="æˆ¦å ´"></div>
      <div id="toast"></div>

      <!-- ã‚¿ã‚¤ãƒˆãƒ«/é›£æ˜“åº¦/ãƒªã‚¶ãƒ«ãƒˆç”¨ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ -->
      <div id="overlay" class="overlay show" role="dialog" aria-modal="true">
        <div class="panel">
          <h1>Mobile TD â€” è¿·è·¯å‹ã‚¿ãƒ¯ãƒ¼ãƒ‡ã‚£ãƒ•ã‚§ãƒ³ã‚¹</h1>
          <p>ã‚¿ãƒƒãƒ—ï¼†ãƒ‰ãƒ©ãƒƒã‚°ã§ã‚¿ãƒ¯ãƒ¼/ç½ /ãƒ¦ãƒ‹ãƒƒãƒˆã‚’é…ç½®ã€‚å…¨10ã‚¦ã‚§ãƒ¼ãƒ–ã‚’é˜²è¡›ã›ã‚ˆï¼</p>
          <h2>é›£æ˜“åº¦ã‚’é¸æŠ</h2>
          <div class="row" id="difficulty">
            <button class="chip" data-diff="easy">Easy</button>
            <button class="chip sel" data-diff="normal">Normal</button>
            <button class="chip" data-diff="hard">Hard</button>
          </div>
          <div class="row" style="justify-content:flex-end;margin-top:12px">
            <button class="btn" id="btnStartGame">ã‚²ãƒ¼ãƒ é–‹å§‹</button>
          </div>
        </div>
      </div>

      <div id="result" class="overlay" role="dialog" aria-modal="true">
        <div class="panel">
          <h1 id="resultTitle">çµæœ</h1>
          <p id="resultStats"></p>
          <div class="row" style="justify-content:flex-end;margin-top:12px">
            <button class="btn" id="btnBackTitle">ã‚¿ã‚¤ãƒˆãƒ«ã¸</button>
          </div>
        </div>
      </div>
    </div>

    <!-- ä¸‹éƒ¨UIãƒãƒ¼ -->
    <div id="bar">
      <div id="stats">
        <div>ğŸ’° <b id="money">0</b></div>
        <div>â¤ï¸ <b id="life">0</b></div>
        <div>ğŸ“¶ Wave <b id="wave">0</b>/10</div>
      </div>
      <div id="palette" aria-label="é…ç½®ãƒ‘ãƒ¬ãƒƒãƒˆ">
        <!-- å‹•çš„ã«ç”Ÿæˆ -->
      </div>
    </div>
  </div>

<script>
(()=>{
  "use strict";
  /**
   * Mobile TD v0.1
   * - è¿·è·¯å‹ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é…ç½®ã§çµŒè·¯ãŒå¤‰åŒ–ï¼‰
   * - ã‚¿ãƒƒãƒ—ï¼†ãƒ‰ãƒ©ãƒƒã‚°é…ç½®ï¼ˆãƒ‰ãƒ©ãƒƒã‚°ã—ã¥ã‚‰ã„ç«¯æœ«å‘ã‘ã«ã‚¿ãƒƒãƒ—2å›ã‚‚ã‚µãƒãƒ¼ãƒˆï¼‰
   * - å…¨10Wave / é›£æ˜“åº¦é¸æŠ / ã‚·ãƒ³ã‚°ãƒ«ãƒ—ãƒ¬ã‚¤
   */

  /* ===== ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ===== */
  const $ = (sel, el=document)=>el.querySelector(sel);
  const $$ = (sel, el=document)=>Array.from(el.querySelectorAll(sel));
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
  const rand = (a,b)=>a+Math.random()*(b-a);

  const toastEl = $('#toast');
  let toastTimer=null;
  function toast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    clearTimeout(toastTimer);
    toastTimer = setTimeout(()=>toastEl.classList.remove('show'), 1200);
  }

  /* ===== å®šæ•°ãƒ»ã‚²ãƒ¼ãƒ è¨­å®š ===== */
  const GRID_W = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--grid-w'));
  const GRID_H = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--grid-h'));
  const TILE = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile'));

  const START = {x:0, y:Math.floor(GRID_H/2)};  // å·¦ä¸­å¤®ã‹ã‚‰ã‚¹ãƒãƒ¼ãƒ³
  const GOAL  = {x:GRID_W-1, y:Math.floor(GRID_H/2)}; // å³ä¸­å¤®ãŒã‚´ãƒ¼ãƒ«

  const DIFFS = {
    easy:   { enemyHP:0.9, enemyNum:0.9, reward:1.15, startMoney: 220, life:24 },
    normal: { enemyHP:1.0, enemyNum:1.0, reward:1.0,  startMoney: 180, life:20 },
    hard:   { enemyHP:1.2, enemyNum:1.15,reward:0.9,  startMoney: 150, life:18 },
  };

  // ãƒ‘ãƒ¬ãƒƒãƒˆå®šç¾©ï¼ˆã‚¿ãƒ¯ãƒ¼/ç½ /ãƒ¦ãƒ‹ãƒƒãƒˆï¼‰
  const ITEMS = [
    { key:'tower_basic',  kind:'tower', name:'åŸºæœ¬',   cost:60,  range:2.5, dmg:10,  rof:1.0, iconClass:'tower' },
    { key:'tower_sniper', kind:'tower', name:'ç‹™æ’ƒ',   cost:110, range:5.0, dmg:30,  rof:0.4, iconClass:'tower sniper' },
    { key:'tower_mg',     kind:'tower', name:'é€£å°„',   cost:85,  range:2.2, dmg:6,   rof:3.0, iconClass:'tower mg' },

    { key:'trap_mine',    kind:'trap',  name:'åœ°é›·',   cost:35,  iconClass:'trap mine' },
    { key:'trap_slow',    kind:'trap',  name:'æ¸›é€Ÿ',   cost:55,  slow:0.55, iconClass:'trap slow' },

    { key:'unit_inf',     kind:'unit',  name:'æ­©å…µ',   cost:50,  range:1.8, dmg:8,   rof:1.2, iconClass:'unit infantry' },
    { key:'unit_vehicle', kind:'unit',  name:'è»Šä¸¡',   cost:120, range:2.4, dmg:14,  rof:1.0, iconClass:'unit vehicle' },
  ];

  // ã‚¦ã‚§ãƒ¼ãƒ–æ§‹æˆï¼ˆæ•µã‚¹ãƒãƒ¼ãƒ³ãƒ†ãƒ¼ãƒ–ãƒ«ï¼‰
  const WAVES = [
    // type: 'inf'|'bike'|'tank'|'boss'
    { list:[ {type:'inf', n:12, gap:0.7} ] },
    { list:[ {type:'inf', n:16, gap:0.65} ] },
    { list:[ {type:'inf', n:18, gap:0.6} ] },
    { list:[ {type:'inf', n:16, gap:0.5},{type:'bike', n:6, gap:0.9} ] },
    { list:[ {type:'bike', n:10, gap:0.8},{type:'inf', n:10, gap:0.6} ] },
    { list:[ {type:'bike', n:14, gap:0.7} ] },
    { list:[ {type:'tank', n:5, gap:1.2},{type:'bike', n:8, gap:0.8} ] },
    { list:[ {type:'tank', n:6, gap:1.1},{type:'inf', n:12, gap:0.6} ] },
    { list:[ {type:'tank', n:8, gap:1.0} ] },
    { list:[ {type:'boss', n:1, gap:0.0} ] },
  ];

  const ENEMY_BASE = {
    inf:  { hp: 30,  spd: 1.0, reward: 6,  dmg:1, class:'enemy' },
    bike: { hp: 26,  spd: 1.8, reward: 8,  dmg:1, class:'enemy bike' },
    tank: { hp: 180, spd: 0.6, reward: 20, dmg:2, class:'enemy tank' },
    boss: { hp: 1200,spd: 0.5, reward: 120,dmg:5, class:'enemy boss' },
  };

  /* ===== ã‚°ãƒªãƒƒãƒ‰ç”Ÿæˆ ===== */
  const gridEl = $('#grid');
  // ã‚»ãƒ³ã‚¿ãƒªãƒ³ã‚°ã®ãŸã‚ã«ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãƒ©ãƒƒãƒ‘ã®é«˜ã•ã‚’å¯å¤‰ã«ã™ã‚‹
  function resizeField(){
    // ç”»é¢é«˜ã•ã‹ã‚‰ä¸‹éƒ¨ãƒãƒ¼ã‚’å¼•ã„ãŸé ˜åŸŸã§ä¸­å¤®å¯„ã›
    const rect = gridEl.getBoundingClientRect();
    const wrap = $('#fieldWrap');
    wrap.style.minHeight = `calc(100vh - var(--bar))`;
  }
  window.addEventListener('resize', resizeField);

  const map = createBaseMap();
  function createBaseMap(){
    // 0:ç©ºã 1:éšœå®³ï¼ˆå£ï¼‰ 2:ã‚¹ãƒ­ãƒ¼ 3:åœ°é›· 4:ã‚¿ãƒ¯ãƒ¼/ãƒ¦ãƒ‹ãƒƒãƒˆ
    const arr = Array.from({length:GRID_H},()=>Array(GRID_W).fill(0));
    // ãƒ‡ãƒ•ã‚©ã§é€šã‚Šé“ãŒä¸€æœ¬ã‚ã‚‹ã‚ˆã†ã€ä¸Šä¸‹ã«ä½ã„å£ã‚’ç½®ãï¼ˆè¿·è·¯ã‚‰ã—ã•ï¼‰
    for(let x=2;x<GRID_W-2;x++){
      const y1 = Math.floor(GRID_H/2)-3;
      const y2 = Math.floor(GRID_H/2)+3;
      if(x % 4 !== 0){ // ã¨ã“ã‚ã©ã“ã‚æ¬ ã‘ã‚’ä½œã‚‹
        arr[y1][x] = 1;
        arr[y2][x] = 1;
      }
    }
    // ã‚¹ã‚¿ãƒ¼ãƒˆ/ã‚´ãƒ¼ãƒ«ã¯å¿…ãšç©ºã
    arr[START.y][START.x]=0; arr[GOAL.y][GOAL.x]=0;
    return arr;
  }

  function renderGrid(){
    gridEl.innerHTML = '';
    gridEl.style.setProperty('--grid-w', GRID_W);
    gridEl.style.setProperty('--grid-h', GRID_H);
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        const d = document.createElement('div');
        d.className = 'cell';
        d.dataset.x = x; d.dataset.y = y;
        if((x===START.x && y===START.y)) d.classList.add('start');
        if((x===GOAL.x && y===GOAL.y)) d.classList.add('goal');
        gridEl.appendChild(d);
      }
    }
  }
  renderGrid();
  resizeField();

  /* ===== çµŒè·¯æ¢ç´¢ï¼ˆA*ï¼‰ ===== */
  function astar(start, goal, mapOverride){
    const grid = mapOverride || map;
    const key=(x,y)=>`${x},${y}`;
    const open=[{x:start.x,y:start.y,g:0,f:0}];
    const came=new Map();
    const gscore=new Map([[key(start.x,start.y),0]]);
    const fscore=new Map([[key(start.x,start.y),heur(start,goal)]]);

    function heur(a,b){return Math.abs(a.x-b.x)+Math.abs(a.y-b.y);} // ãƒãƒ³ãƒãƒƒã‚¿ãƒ³
    function neighbors(x,y){
      const arr=[];
      [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
        const nx=x+dx, ny=y+dy;
        if(nx>=0&&nx<GRID_W&&ny>=0&&ny<GRID_H && grid[ny][nx]!==1 && grid[ny][nx]!==4){
          arr.push({x:nx,y:ny});
        }
      });
      return arr;
    }

    while(open.length){
      // æœ€å°fã®ãƒãƒ¼ãƒ‰ã‚’å–ã‚Šå‡ºã™
      let best=0; for(let i=1;i<open.length;i++){ if(open[i].f<open[best].f) best=i; }
      const cur=open.splice(best,1)[0];
      if(cur.x===goal.x && cur.y===goal.y){
        // ãƒ‘ã‚¹å¾©å…ƒ
        const path=[{x:cur.x,y:cur.y}];
        let ck=key(cur.x,cur.y);
        while(came.has(ck)){
          const p=came.get(ck); path.push(p); ck=key(p.x,p.y);
        }
        return path.reverse();
      }
      for(const nb of neighbors(cur.x,cur.y)){
        const tentative = (gscore.get(key(cur.x,cur.y)) ?? Infinity) + 1;
        const nk = key(nb.x,nb.y);
        if(tentative < (gscore.get(nk) ?? Infinity)){
          came.set(nk,{x:cur.x,y:cur.y});
          gscore.set(nk, tentative);
          const f = tentative + heur(nb, goal);
          fscore.set(nk, f);
          if(!open.find(n=>n.x===nb.x&&n.y===nb.y)) open.push({x:nb.x,y:nb.y,g:tentative,f});
        }
      }
    }
    return null; // ãƒ‘ã‚¹ãŒãªã„
  }

  let currentPath = astar(START, GOAL);
  paintPath(currentPath);
  function paintPath(path){
    $$('.cell').forEach(c=>c.classList.remove('path'));
    if(!path) return;
    for(const p of path){
      const cell = $(`.cell[data-x="${p.x}"][data-y="${p.y}"]`);
      if(cell && !cell.classList.contains('start') && !cell.classList.contains('goal')){
        cell.classList.add('path');
      }
    }
  }

  /* ===== ã‚²ãƒ¼ãƒ çŠ¶æ…‹ ===== */
  const state = {
    running:false,
    paused:false,
    speed:1,
    diff:'normal',
    money:0,
    life:20,
    wave:0,
    enemies:[],
    towers:[],
    units:[],
    traps:[],
    bullets:[],
  };

  /* ===== UI ===== */
  const moneyEl=$('#money'), lifeEl=$('#life'), waveEl=$('#wave');
  function refreshStats(){ moneyEl.textContent = state.money|0; lifeEl.textContent = state.life; waveEl.textContent = state.wave; }

  function buildPalette(){
    const pal = $('#palette'); pal.innerHTML='';
    ITEMS.forEach((it,i)=>{
      const d=document.createElement('button'); d.className='item'; d.type='button'; d.dataset.key=it.key; d.dataset.index=i;
      d.innerHTML = `<div class="ico ${it.iconClass}"></div><div class="name">${it.name}</div><div class="cost">${it.cost}</div>`;
      pal.appendChild(d);
    });
  }
  buildPalette();

  /* ===== é…ç½®ï¼ˆã‚¿ãƒƒãƒ—ï¼†ãƒ‰ãƒ©ãƒƒã‚°ï¼‰ ===== */
  let placing = null; // { item, ghostEl }
  let placingCell = null;

  $('#palette').addEventListener('pointerdown', (e)=>{
    const btn = e.target.closest('.item'); if(!btn) return;
    const idx = +btn.dataset.index; const item = ITEMS[idx];
    startPlacing(item, e);
  });

  function startPlacing(item, e){
    if(state.paused){ toast('ä¸€æ™‚åœæ­¢ä¸­'); return; }
    if(state.money < item.cost){ toast('ãŠé‡‘ãŒè¶³ã‚Šã¾ã›ã‚“'); return; }
    $$('.item').forEach(x=>x.classList.remove('sel'));
    const src = $(`.item[data-key="${item.key}"]`); if(src) src.classList.add('sel');
    const g=document.createElement('div'); g.className='ghost';
    const size = item.kind==='trap' && item.key==='trap_slow' ? 34 : 30;
    g.style.width = size+'px'; g.style.height = size+'px';
    gridEl.appendChild(g);
    placing = { item, ghostEl:g };
    moveGhost(e);

    // ãƒ‰ãƒ©ãƒƒã‚°ã§é…ç½®
    window.addEventListener('pointermove', moveGhost);
    window.addEventListener('pointerup', endPlacing, { once:true });
  }

  function moveGhost(e){
    if(!placing) return;
    const r = gridEl.getBoundingClientRect();
    const gx = clamp(Math.floor((e.clientX - r.left)/TILE), 0, GRID_W-1);
    const gy = clamp(Math.floor((e.clientY - r.top)/TILE), 0, GRID_H-1);
    placingCell = {x:gx,y:gy};
    const cx = gx*TILE + TILE/2; const cy = gy*TILE + TILE/2;
    placing.ghostEl.style.left = cx+'px'; placing.ghostEl.style.top = cy+'px';
  }

  function endPlacing(e){
    window.removeEventListener('pointermove', moveGhost);
    if(!placingCell){ cancelPlacing(); return; }
    tryPlace(placing.item, placingCell.x, placingCell.y);
    cancelPlacing();
  }

  function cancelPlacing(){
    if(placing){ placing.ghostEl.remove(); placing=null; }
    $$('.item').forEach(x=>x.classList.remove('sel'));
  }

  function cellBlockedForPlacement(x,y){
    // å£ã‚„ã‚¹ã‚¿ãƒ¼ãƒˆ/ã‚´ãƒ¼ãƒ«ã«ã¯ç½®ã‘ãªã„
    if((x===START.x&&y===START.y) || (x===GOAL.x&&y===GOAL.y)) return true;
    if(map[y][x]===1) return true;
    return false;
  }

  function tryPlace(item, x, y){
    if(cellBlockedForPlacement(x,y)){ toast('ã“ã“ã«ã¯ç½®ã‘ã¾ã›ã‚“'); return; }

    // ä»®é…ç½®ã—ã€çµŒè·¯ãŒå¡ãŒã‚Œã¦ã„ãªã„ã‹ç¢ºèª
    const temp = map.map(row=>row.slice());
    // ã‚¿ãƒ¯ãƒ¼/ãƒ¦ãƒ‹ãƒƒãƒˆã¯é€šè¡Œä¸å¯ï¼ˆ4ï¼‰ã€ç½ ã¯é€šè¡Œå¯ï¼ˆã‚¹ãƒ­ãƒ¼=2ã€åœ°é›·=3ï¼‰
    if(item.kind==='trap'){
      if(item.key==='trap_slow'){
        if(temp[y][x]!==0) { toast('ã“ã“ã«ã¯ç½®ã‘ã¾ã›ã‚“'); return; }
        temp[y][x]=2;
      }else if(item.key==='trap_mine'){
        if(temp[y][x]!==0) { toast('ã“ã“ã«ã¯ç½®ã‘ã¾ã›ã‚“'); return; }
        temp[y][x]=3;
      }
    }else{
      if(temp[y][x]!==0) { toast('ã“ã“ã«ã¯ç½®ã‘ã¾ã›ã‚“'); return; }
      temp[y][x]=4; // é€šè¡Œä¸å¯
    }

    const p = astar(START, GOAL, temp);
    if(!p){ toast('çµŒè·¯ã‚’ãµã•ã’ã¾ã›ã‚“'); return; }

    // æ­£å¼é…ç½®
    if(state.money < item.cost){ toast('ãŠé‡‘ãŒè¶³ã‚Šã¾ã›ã‚“'); return; }
    state.money -= item.cost; refreshStats();

    if(item.kind==='trap'){
      if(item.key==='trap_slow'){ map[y][x]=2; spawnTrap(x,y,'slow',item); }
      else { map[y][x]=3; spawnTrap(x,y,'mine',item); }
    }else if(item.kind==='tower'){
      map[y][x]=4; spawnTower(x,y,item);
    }else if(item.kind==='unit'){
      map[y][x]=4; spawnUnit(x,y,item);
    }

    currentPath = p; paintPath(currentPath);
  }

  /* ===== ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ç”Ÿæˆ ===== */
  function placeEntityEl(cls, x, y){
    const el=document.createElement('div'); el.className='entity '+cls;
    el.style.left = (x*TILE + TILE/2)+'px';
    el.style.top  = (y*TILE + TILE/2)+'px';
    gridEl.appendChild(el);
    return el;
  }

  function spawnTower(x,y,item){
    const el = placeEntityEl(item.iconClass, x,y);
    const o = { kind:'tower', x, y, px:x*TILE+TILE/2, py:y*TILE+TILE/2, range:item.range*TILE, dmg:item.dmg, rof:item.rof, cd:0, el };
    state.towers.push(o);
  }
  function spawnUnit(x,y,item){
    const el = placeEntityEl(item.iconClass, x,y);
    const o = { kind:'unit', x, y, px:x*TILE+TILE/2, py:y*TILE+TILE/2, range:item.range*TILE, dmg:item.dmg, rof:item.rof, cd:0, el };
    state.units.push(o);
  }
  function spawnTrap(x,y,type,item){
    const el = placeEntityEl(type==='slow'?'trap slow':'trap mine', x,y);
    state.traps.push({x,y,type,slow:item.slow??0.55, used:false, el});
  }

  function spawnEnemy(type){
    const base = ENEMY_BASE[type];
    const el = placeEntityEl(base.class, START.x, START.y);
    const hpMax = Math.ceil(base.hp * DIFFS[state.diff].enemyHP);
    const o = {
      type, el,
      hp:hpMax, hpMax,
      spd:base.spd,
      reward: Math.round(base.reward * DIFFS[state.diff].reward),
      dmg:base.dmg,
      // çµŒè·¯ä¸Šã®ä½ç½®
      path: currentPath.slice(),
      pathIndex:0, // æ¬¡ã®ã‚»ãƒ«ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
      x: START.x*TILE+TILE/2, y: START.y*TILE+TILE/2,
      slowTimer:0,
    };
    state.enemies.push(o);
  }

  function fire(from, to){
    const el = placeEntityEl('bullet', from.px/ TILE, from.py/ TILE);
    const b = { el, x:from.px, y:from.py, tx:to.x, ty:to.y, spd: 480, dmg: from.dmg };
    state.bullets.push(b);
  }

  /* ===== ã‚¦ã‚§ãƒ¼ãƒ–ç®¡ç† ===== */
  let waveTimer=0, spawnQueue=[];
  function setupWave(n){
    state.wave = n; refreshStats();
    const conf = WAVES[n-1];
    spawnQueue = [];
    const mult = DIFFS[state.diff].enemyNum;
    for(const e of conf.list){
      const count = Math.round(e.n * mult);
      for(let i=0;i<count;i++) spawnQueue.push({type:e.type, at: (spawnQueue.at(-1)?.at??0) + e.gap});
    }
    waveTimer = 0;
  }

  let intermission = true; // Waveé–“ã®å°ä¼‘æ­¢

  function startWave(){
    if(state.wave>=10){ return; }
    intermission=false;
    setupWave(state.wave+1);
    toast(`Wave ${state.wave} é–‹å§‹!`);
  }

  function endWave(){
    // ç”Ÿå­˜æ•µãŒã„ãªãã€ã‚­ãƒ¥ãƒ¼ã‚‚ç©º â†’ ãƒœãƒ¼ãƒŠã‚¹
    const bonus = Math.round(40 * DIFFS[state.diff].reward);
    state.money += bonus; refreshStats();
    toast(`Wave ${state.wave} ã‚¯ãƒªã‚¢ï¼ +${bonus}`);
    intermission=true;
    if(state.wave>=10){ victory(); }
  }

  function victory(){
    state.running=false; showResult(true);
  }
  function defeat(){
    state.running=false; showResult(false);
  }

  function showResult(win){
    const res = $('#result');
    $('#resultTitle').textContent = win? 'å‹åˆ©ï¼':'æ•—åŒ—â€¦';
    $('#resultStats').textContent = `åˆ°é”Wave: ${state.wave} / æ‰€æŒé‡‘: ${state.money}`;
    res.classList.add('show');
  }

  /* ===== ãƒ«ãƒ¼ãƒ— ===== */
  let last=0;
  function loop(t){
    if(!state.running){ last=t; requestAnimationFrame(loop); return; }
    const dt = Math.min(0.05, (t-last)/1000) * (state.speed||1); // ç§’
    last=t;
    if(!state.paused){
      update(dt);
    }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  function update(dt){
    // ã‚¹ãƒãƒ¼ãƒ³å‡¦ç†
    if(!intermission && spawnQueue.length){
      waveTimer += dt;
      while(spawnQueue.length && waveTimer >= spawnQueue[0].at){
        const q = spawnQueue.shift();
        spawnEnemy(q.type);
      }
    }

    // æ•µã®ç§»å‹•
    for(const e of state.enemies){
      if(!e.path || e.path.length===0) e.path = currentPath.slice();
      // æ¬¡ã®ã‚¿ã‚¤ãƒ«ä¸­å¿ƒ
      const next = e.path[e.pathIndex+1];
      if(!next){
        // ã‚´ãƒ¼ãƒ«åˆ°é”
        e.el.remove();
        state.enemies.splice(state.enemies.indexOf(e),1);
        state.life -= (e.dmg||1); refreshStats();
        if(state.life<=0){ defeat(); }
        break;
      }
      const nx = next.x*TILE+TILE/2, ny = next.y*TILE+TILE/2;
      const dx = nx - e.x, dy = ny - e.y; const dist = Math.hypot(dx,dy);
      let spd = e.spd * 60; // px/s â†’ èª¿æ•´
      if(e.slowTimer>0){ spd *= 0.5; e.slowTimer -= dt; }
      const step = Math.min(dist, spd*dt);
      e.x += dx/dist*step; e.y += dy/dist*step;
      e.el.style.left = e.x+'px'; e.el.style.top = e.y+'px';
      if(dist<2){ e.pathIndex++; }

      // ãƒˆãƒ©ãƒƒãƒ—ãƒã‚§ãƒƒã‚¯
      const cx = Math.floor(e.x/TILE), cy = Math.floor(e.y/TILE);
      const cell = map[cy]?.[cx];
      if(cell===2){ // æ¸›é€Ÿ
        e.slowTimer = 0.6;
      }else if(cell===3){ // åœ°é›·
        map[cy][cx]=0; // ä½¿ç”¨æ¸ˆã¿
        const tr = state.traps.find(t=>t.x===cx&&t.y===cy&&t.type==='mine');
        if(tr){ tr.el.remove(); state.traps.splice(state.traps.indexOf(tr),1); }
        damageEnemy(e, 90);
      }
    }

    // ã‚¿ãƒ¯ãƒ¼/ãƒ¦ãƒ‹ãƒƒãƒˆã®æ”»æ’ƒ
    const shooters = [...state.towers, ...state.units];
    for(const s of shooters){
      s.cd -= dt; if(s.cd>0) continue;
      // å°„ç¨‹å†…ã®æœ€ã‚‚ã‚´ãƒ¼ãƒ«ã«è¿‘ã„æ•µ
      let target=null, best= -1;
      for(const e of state.enemies){
        const d = Math.hypot(e.x - s.px, e.y - s.py);
        if(d<=s.range){
          const prog = e.pathIndex + d/ (TILE*1.0);
          if(prog>best){ best=prog; target=e; }
        }
      }
      if(target){ fire(s, target); s.cd = 1.0/ s.rof; }
    }

    // å¼¾ã®ç§»å‹•ï¼†å‘½ä¸­
    for(let i=state.bullets.length-1;i>=0;i--){
      const b=state.bullets[i];
      const dx=b.tx - b.x, dy=b.ty - b.y; const dist=Math.hypot(dx,dy);
      const step = Math.min(dist, b.spd*dt);
      b.x += dx/dist*step; b.y += dy/dist*step;
      b.el.style.left=b.x+'px'; b.el.style.top=b.y+'px';
      if(dist<6){
        // è¿‘ã„æ•µã‚’æ¤œç´¢ï¼ˆå‘½ä¸­å‡¦ç†ï¼‰
        let hit=null, best=Infinity;
        for(const e of state.enemies){
          const d=Math.hypot(e.x-b.x, e.y-b.y); if(d<best){ best=d; hit=e; }
        }
        if(hit && best<20){ damageEnemy(hit, b.dmg); }
        b.el.remove(); state.bullets.splice(i,1);
      }
    }

    // Waveçµ‚äº†ãƒã‚§ãƒƒã‚¯
    if(!intermission && spawnQueue.length===0 && state.enemies.length===0){
      endWave();
    }
  }

  function damageEnemy(e, dmg){
    e.hp -= dmg; flashEl(e.el);
    if(e.hp<=0){
      e.el.remove();
      state.enemies.splice(state.enemies.indexOf(e),1);
      state.money += e.reward; refreshStats();
    }
  }

  function flashEl(el){
    el.animate([{filter:'brightness(1)'},{filter:'brightness(2)'}],{duration:120});
  }

  /* ===== ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« ===== */
  $('#btnStartWave').addEventListener('click', ()=>{
    if(intermission){ startWave(); }
  });
  $('#btnPause').addEventListener('click', ()=>{
    state.paused = !state.paused; toast(state.paused? 'ä¸€æ™‚åœæ­¢' : 'å†é–‹');
  });
  $('#btnSpeed').addEventListener('click', (e)=>{
    state.speed = state.speed===1? 1.5 : state.speed===1.5? 2 : 1;
    e.target.textContent = `é€Ÿåº¦Ã—${state.speed}`;
  });

  // é›£æ˜“åº¦é¸æŠã¨é–‹å§‹
  let chosenDiff = 'normal';
  $('#difficulty').addEventListener('click', (e)=>{
    const c = e.target.closest('.chip'); if(!c) return;
    chosenDiff = c.dataset.diff; $$('#difficulty .chip').forEach(x=>x.classList.toggle('sel', x===c));
  });

  $('#btnStartGame').addEventListener('click', ()=>{
    const d = DIFFS[chosenDiff];
    Object.assign(state, { running:true, paused:false, speed:1, diff:chosenDiff, money:d.startMoney, life:d.life, wave:0 });
    refreshStats();
    $('#overlay').classList.remove('show');
    intermission = true;
    toast('æº–å‚™ãƒ•ã‚§ãƒ¼ã‚ºï¼šé…ç½®ã—ã¦ã‹ã‚‰Waveé–‹å§‹ã‚’æŠ¼ã—ã¦ãã ã•ã„');
  });

  $('#btnBackTitle').addEventListener('click', ()=>{
    location.reload();
  });

})();
</script>
</body>
</html>
